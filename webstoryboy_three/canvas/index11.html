<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
        }

        .canvasTTL p {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translateY(-50%) translateX(-50%) scale(1.0, 1.2);
            text-align: center;
            vertical-align: middle;
            margin: auto;
            letter-spacing: 0px;
            font-family: 'Oswald', sans-serif;
            font-size: 6vw;
            color: #fff;
        }

        @media screen and (max-width: 1024px) {
            .canvasTTL p {
                font-size: 12vw;
            }
        }

        #myCanvas canvas {
            background: #03a9f4;
            height: 100%;
            width: 100%;
            position: absolute;
        }
    </style>
</head>

<body>
    <div id="myCanvas">
        <canvas></canvas>
    </div>

    <script src="https://dl.dropbox.com/s/m1qor6z15o64wkc/stats.min.js?dl=0"></script>
    <script src="https://dl.dropbox.com/s/sk7fbhx9burholi/dat.gui.min.js?dl=0"></script>
    <script>
        window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;

        var canvas = document.querySelector("canvas");
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight;

        var ctx = canvas.getContext("2d");
        ctx.globalCompositeOperation = "source-over"; 

        //stats.js
        // var stats = new Stats();
        // document.body.appendChild(stats.dom);

        var particles = [];
        var pIndex = 0;
        var x, y, frameId;

        //Particle
        function Particle(x, vx, vy, color, size) {
            this.x = x;
            this.y = -canvas.height / 2;
            this.vx = vx;
            this.vy = vy;
            this.color = color;
            particles[pIndex] = this;
            this.id = pIndex;
            pIndex++;
            this.life = 0;
            this.maxlife = 600;
            this.degree = getRandom(0, 360); // 각도 변경
            this.size = Math.floor(getRandom(size * 0.8, size)); //크기 변경
        };
        Particle.prototype.draw = function () {
            this.degree += 1;
            this.vx *= 0.99; 
            this.vy *= 0.999; 
            this.x += this.vx + Math.cos(this.degree * Math.PI / 180); 
            this.y += this.vy;
            this.width = this.size;
            this.height = Math.cos(this.degree * Math.PI / 45) * this.size; 

            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.moveTo(this.x + this.x / 2, this.y + this.y / 2);
            ctx.lineTo(this.x + this.x / 2 + this.width / 2, this.y + this.y / 2 + this.height);
            ctx.lineTo(this.x + this.x / 2 + this.width + this.width / 2, this.y + this.y / 2 + this
            .height);
            ctx.lineTo(this.x + this.x / 2 + this.width, this.y + this.y / 2);
            ctx.closePath();
            ctx.fill();
            this.life++;

            //색종이 제거
            if (this.life >= this.maxlife) {
                delete particles[this.id];
            }
        }


        //GUI
        var params, params_A, params_B, params_C;

        function setGUI() {
            params = {
                'colorful_mode': false,
                'amount': 5,
                'bg_color': "#222",
                'vx': 2,
                'vy': 4,
                'size': 10

            };
            params_A = {
                'color': "#ED1A3D",
            };
            params_B = {
                'color': "#FFF",
            };

            var gui = new dat.GUI();
            gui.add(params, 'colorful_mode');
            gui.add(params, 'amount', 1.0, 10).step(1);
            gui.addColor(params, 'bg_color');
            gui.add(params, 'vx', 1.0, 10).step(0.1);
            gui.add(params, 'vy', 1.0, 10).step(0.1);
            gui.add(params, 'size', 5, 30).step(1);

            var fA = gui.addFolder('particle_A')
            fA.addColor(params_A, 'color');

            var fB = gui.addFolder('particle_B')
            fB.addColor(params_B, 'color');

        }
        setGUI();

        //アニメーション
        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); //画面の更新
            canvas.style.background = params.bg_color; //背景色変更



            if (frameId % (11 - params.amount) == 0) {
                //カラフルモードがONの時色がカラフルになる
                if (params.colorful_mode) {
                    var hue = Math.floor(getRandom(0, 12.99)) * 30;
                    var hsl_color = "hsl(" + hue + ", 80%, 60%)";
                    new Particle(canvas.width * Math.random(), getRandom(-params.vx, params.vx), getRandom(
                        params.vy - 2, params.vy), hsl_color, params.size);
                } else {
                    var x1 = canvas.width * Math.random() + canvas.width / 2 * Math.random();
                    var x2 = canvas.width * Math.random() - canvas.width / 2 * Math.random();
                    new Particle(x1, -1 * getRandom(params.vx - 2, params.vx), getRandom(params.vy - 2, params
                        .vy), params_A.color, params.size);
                    new Particle(x2, getRandom(params.vx - 2, params.vx), getRandom(params.vy - 2, params.vy),
                        params_B.color, params.size);
                }

            }

            for (var i in particles) {
                particles[i].draw();
            }
            frameId = requestAnimationFrame(loop);
            if (frameId % 2 == 0) {
                return;
            } //60fpsを30fpsにする
            stats.update();
        }
        loop();


        //全画面リサイズ
        window.addEventListener("resize", function () {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            x = canvas.width / 2;
            y = canvas.height / 2;
        });

        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }


    </script>
</body>

</html>