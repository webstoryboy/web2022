[
    {
        "subject": "소프트웨어 설계",
        "question": "UML 다이어그램 중 순차 다이어그램에 대한 설명으로 틀린 것은?",
        "correct_answer": "주로 시스템의 정적 측면을 모델링하기 위해 사용한다.",
        "incorrect_answers": ["객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링 하는 것이다.","회귀 메시지(Self-Message), 제어블록(Statement block) 등으로 구성된다","일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다."],
        "desc": "주로 시스템의 동적 측면을 모델링하기 위해 사용한다."
    },{
        "subject": "소프트웨어 설계",
        "question": "메시지 지향 미들웨어(Message-Oriented Middleware, MOM)에 대한 설명으로 틀린 것은?",
        "correct_answer": "느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.",
        "incorrect_answers": ["독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다","송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다","상이한 애플리케이션 간 통신을 비동기 방식으로 지원한다"],
        "keyword": "미들웨어",
        "desc": "MOM(MessgaeOriented Middleware): 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이며, 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다."
    },{
        "subject": "소프트웨어 설계",
        "question": "익스트림 프로그래밍에 대한 설명으로 틀린 것은?",
        "correct_answer": "대표적인 구조적 방법론 중 하나이다.",
        "incorrect_answers": ["소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다","익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어 올리는 것이다","구체적인 실천 방법을 정의하고 있으며, 개발 문서 보다는 소스코드에 중점을 둔다."],
        "desc": "익스트림 프로그래밍(eXtreme Programming, XP)은 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이며, 애자일 모델이다.",
        "keyword": "익스트림 프로그래밍"
    },{
        "subject": "소프트웨어 설계",
        "question": "유스케이스(Use Case)의 구성 요소 간의 관계에 포함되지 않는 것은?",
        "correct_answer": "구체화",
        "incorrect_answers": ["확장","연관","일반화"],
        "keyword": "유스케이스"
    },{
        "subject": "소프트웨어 설계",
        "question": "요구사항 분석에서 비기능적(Nonfunctional) 요구에 대한 설명으로 옳은 것은?",
        "correct_answer": "'차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다'는 비기능적 요구이다.",
        "incorrect_answers": ["시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다.","시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다","'금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다'는 비기능적 요구이다."],
        "desc": "기능적 요구사항은 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항이고, 비기능적 요구사항은 시스템 구축에 대한 성능, 보안, 품질, 안정 등에 대한 성능, 보안, 품질, 안정성등으로 실제 수행에보조적인 요구사항을 말한다."
    },{
        "subject": "소프트웨어 설계",
        "question": "정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어는?",
        "correct_answer": "Entity-Relationship Diagram",
        "incorrect_answers": ["Package Diagram","State Transition Diagram","Deployment Diagram"]
    },{
        "subject": "소프트웨어 설계",
        "question": "미들웨어(Middleware)에 대한 설명으로 틀린 것은?",
        "correct_answer": "미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.",
        "incorrect_answers": ["여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다","소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다","여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러 가지 형태로 연결이 가능하다."],
        "keyword": "미들웨어"
    },{
        "subject": "소프트웨어 설계",
        "question": "UI의 설계 지침으로 틀린 것은?",
        "correct_answer": "치명적인 오류에 대한 부정적인 사항은 사용자가 인지 할 수 없도록 한다",
        "incorrect_answers": ["이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다.","주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다.","사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 한다."],
        "keyword": "UI"
    },{
        "subject": "소프트웨어 설계",
        "question": "객체지향 개념에서 다형성(Polymorphism)과 관련한 설명으로 틀린 것은?",
        "correct_answer": "메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분 할 수 있다.",
        "incorrect_answers": ["다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.","다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다","메소드 오버라이딩(Overriding)은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다."],
        "keyword": "객체지향",
        "desc": "메소드 오버로딩(Overloading)은 메소드명은 같지만, 매개 변수의 개수와 타입을 달리하여 구현하는 개념이다."
    },{
        "subject": "소프트웨어 설계",
        "question": "소프트웨어 개발 영역을 결정하는 요소 중 다음 사항과 관계있는 것은?",
        "question_desc": "- 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어<br>- 기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어<br>- 순서적 연산에 의해 소프트웨어를 실행하는 절차",
        "correct_answer": "인터페이스(Interface)",
        "incorrect_answers": ["기능(Function)","성능(Performance)","제약 조건(Constraint)"]
    },{
        "subject": "소프트웨어 설계",
        "question": "객체에 대한 설명으로 틀린 것은?",
        "correct_answer": "객체는 공통 속성을 공유하는 클래스들의 집합이다.",
        "incorrect_answers": ["객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다","객체의 상태는 속성값에 의해 정의된다","객체는 필요한 자료 구조와 이에 수행되는 함수들을 가진 하나의 독립된 존재이다"],
        "desc": "클래스는 공통 속성을 공유하는 객체의 집합이다. 객체는 객체지향 기술에서의 객체를 의미하며, 객체는 인스턴스의 집합으로 볼 수 있다.",
        "keyword": "객체지향"
    },{
        "subject": "소프트웨어 설계",
        "question": "속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것을 의미하는 객체지향 개념은?",
        "correct_answer": "Encapsulation",
        "incorrect_answers": ["Inheritance","Class","Association"],
        "keyword": "객체지향"
    },{
        "subject": "소프트웨어 설계",
        "question": "애자일(Agile) 프로세스 모델에 대한 설명으로 틀린 것은?",
        "correct_answer": "변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.",
        "incorrect_answers": ["프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다","협상과 계약보다는 고객과의 협력을 중시한다","문서 중심이 아닌, 실행 가능한 소프트웨어를 중시한다"],
        "keyword": "애자일",
        "desc": "애자일 개발 프로세스는 개발에 대한 개념적 방법론으로, 개발 프로젝트 기간을 짧은 주기로 나눠 반복적인 개발을하는 것이 특징이다."
    },{
        "subject": "소프트웨어 설계",
        "question": "명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며, 인터페이스를 통해서만 접근할 수 있는 것은?",
        "correct_answer": "Component",
        "incorrect_answers": ["Model","Sheet","Cell"]
    },{
        "subject": "소프트웨어 설계",
        "question": "GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?",
        "correct_answer": "Builder 패턴",
        "incorrect_answers": ["Adapter 패턴","Bridge 패턴"," Proxy 패턴"],
        "keyword": "디자인 패턴",
        "desc": "생성 패턴에는 추상팩토리(Abstract Factory), 빌더(Builder), 팩토리 메서드(Factory Method), 프로토타입(Prototype), 싱글톤(Sington) 등이 있다. 구조 패턴에는 어댑터(Adapter), 브릿지(Bridge), 컴포지트(Composite), 데코레이터(Decorator), 퍼사드(Facade), 플라이웨잇(Flyseight), 프록시(Proxy) 등이 있다."
    },{
        "subject": "소프트웨어 설계",
        "question": "UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?",
        "correct_answer": "Feedback",
        "incorrect_answers": ["Posture","Module","Hash"],
        "keyword": "UI"
    },{
        "subject": "소프트웨어 설계",
        "question": "UI와 관련된 기본 개념 중 하나로, 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해석할 수 있도록 도와주는 것은?",
        "correct_answer": "NUI(Natural User Interface)",
        "incorrect_answers": ["GUI(Graphical User Interface)","OUI(Organic User Interface)","CLI(Command Line Interface)"],
        "keyword": "UI",
        "desc": "OUI(Organic User Interface) : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스<br>GUI(Graphical User Interface) : 마우스로 선택하여 작업하는 그래픽 환경 인터페이스<br>CLI(Command Line Interface) : 텍스트 형태 인터페이스<br>NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기 조작하는 인터페이스"
    },{
        "subject": "소프트웨어 설계",
        "question": "소프트웨어 모델링과 관련한 설명으로 틀린 것은?",
        "correct_answer": "모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다.",
        "incorrect_answers": ["구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구 사항의 결과를 표현한다.","객체지향 방법론에서는 UML 표기법을 사용한다.","소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다."],
        "keyword": "모델링"
    },{
        "subject": "소프트웨어 설계",
        "question": "유스케이스 다이어그램(Use Case Diagram)에 관련된 내용으로 틀린 것은?",
        "correct_answer": "시스템과 상호작용하는 외부시스템은 액터로 파악해서는 안된다.",
        "incorrect_answers": ["유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다","시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다","액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다"],
        "keyword": "유스케이스",
        "desc": "주 액터 : 시스템을 사용함으로써 이득을 얻는 대상으로, 주로 사람이 해당<br>부 액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관이 될 수 있음"
    },{
        "subject": "소프트웨어 설계",
        "question": "소프트웨어 아키텍처 모델 중 MVC(Model-View-Controller)와 관련한 설명으로 틀린 것은?",
        "correct_answer": "모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브시스템이 각각 하나씩 연결된다.",
        "incorrect_answers": ["MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.","뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.","제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다."],
        "desc": "모델(Model) : 응용 프로그램의 데이터 처리 담당<br>뷰(View) : 모델의 데이터 시각화 담당<br>제어(Controller) : 모델과 업무 로직의 상호작용 담당"
    },{
        "subject": "소프트웨어 개발",
        "question": "통합 테스트(Integration Test)와 관련한 설명으로 틀린 것은?",
        "correct_answer": "상향식 통합 테스트의 경우 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.",
        "incorrect_answers": ["시스템을 구성하는 모듈의 인터페이스와 결합을 테스트하는 것이다","하향식 통합 테스트의 경우 넓이 우선(Breadth First) 방식으로 테스트를 할 모듈을 선택할 수 있다","모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘되고 있는지를 빨리 파악하고자 할 때 상향식 보다는 하향식 통합 테스트를 사용하는 것이 좋다"],
        "keyword": "통합 테스트",
        "desc": "상향식 통합 테스트(하위 모듈에서 상위 모듈 방향으로 통합), 하향식 통합 테스트(상위 모듈에서 하위 모듈 방향으로 통합)"
    },{
        "subject": "소프트웨어 개발",
        "question": " 다음과 같이 레코드가 구성되어 있을 때, 이진 검색 방법 으로 14를 찾을 경우 비교되는 횟수는?",
        "question_desc": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15",
        "correct_answer": "3",
        "incorrect_answers": ["2","4","5"],
        "desc": "이진검색(Binary Search)은 low, middle, high 값을 사용 하고, 찾고자 하는 데이터를 중앙에 위치한 중간값과 비교하는 방법이다. 데이터 목록은 반드시 사전에 오름차순으로 정렬되어 있어야 한다."
    },{
        "subject": "소프트웨어 개발",
        "question": "소프트웨어 공학에서 워크스루(Walkthrough)에 대한 설명으로 틀린 것은?",
        "correct_answer": "인스펙션(Inspection)과 동일한 의미를 가진다.",
        "incorrect_answers": ["사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용할 수 있다","복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.","단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해 보는 것이다."],
        "desc": "워크스루: 요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견<br>인스펙션: 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견."
    },{
        "subject": "소프트웨어 개발",
        "question": "소프트웨어의 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?",
        "correct_answer": "형상관리",
        "incorrect_answers": ["복호화","크랙","저작권"],
        "desc": "복호화(디코딩)은 부호화된 데이터를 부호화 되기 전 형태로 바꾸어, 사람이 읽을 수 있는 형태로 되돌려 놓는 것을 말한다."
    },{
        "subject": "소프트웨어 개발",
        "question": "테스트 케이스와 관련한 설명으로 틀린 것은?",
        "correct_answer": "테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다.",
        "incorrect_answers": ["프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다.","개발된 서비스가 정의된 요구 사항을 준수하는지 확인하기 위한 입력 값과 실행 조건, 예상 결과의 집합으로 볼 수 있다.","테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다."],
        "desc": "테스트케이스(Test Case)는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미한다.",
        "keyword": "테스트 케이스"
    },{
        "subject": "소프트웨어 개발",
        "question": "객체지향 개념을 활용한 소프트웨어 구현과 관련한 설명 중 틀린 것은?",
        "correct_answer": "JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'이다.",
        "incorrect_answers": ["객체(Object)란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재이다.","상속(Inheritance)은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다.","같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스(Instance)라고 한다."],
        "keyword": "객체지향",
        "desc": "JAVA에서 정보은닉(InformationHiding)을 표기할 때 private의 의미는 외부에서 클래스 내부 정보에 접근하지 못하도록 하는 '접근금지'이다."
    },{
        "subject": "소프트웨어 개발",
        "question": "DRM(Digital Rights Management)과 관련한 설명으로 틀린 것은?",
        "correct_answer": "원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다.",
        "incorrect_answers": ["디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다."," 디지털 미디어의 생명 주기 동안 발생하는 사용 권한관리, 과금, 유통 단계를 관리하는 기술로도 볼 수 있다.","클리어링 하우스(Clearing House)는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템을 말한다."],
        "keyword": "DRM"
    },{
        "subject": "소프트웨어 개발",
        "question": "위험 모니터링의 의미로 옳은 것은?",
        "correct_answer": "위험 요소 징후들에 대하여 계속적으로 인지하는 것",
        "incorrect_answers": ["위험을 이해하는 것","첫 번째 조치로 위험을 피할 수 있도록 하는 것","위험 발생 후 즉시 조치하는 것"]
    },{
        "subject": "소프트웨어 개발",
        "question": "동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는",
        "correct_answer": "RCS(Revision Control System)",
        "incorrect_answers": ["RTS(Reliable Transfer Service)","RPC(Remote Procedure Call)","RVS(Relative Version System)"]
    },{
        "subject": "소프트웨어 개발",
        "question": "화이트박스 테스트와 관련한 설명으로 틀린 것은?",
        "correct_answer": "프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다. ",
        "incorrect_answers": ["화이트박스 테스트의 이해를 위해 논리흐름도(Logic-Flow Diagram)를 이용할 수 있다.","테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트(Dynamic Test)에 해당한다","테스트 데이터를 선택하기 위하여 검증기준(Test Coverage)을 정한다"],
        "keyword": "화이트박스 테스트 블랙박스 테스트"
    },{
        "subject": "소프트웨어 개발",
        "question": "알고리즘과 관련한 설명으로 틀린 것은?",
        "correct_answer": "선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.",
        "incorrect_answers": ["주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것으로 볼 수 있다.","정렬(Sorting)은 흩어져있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘이다","검색(Searching)은 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당되는 데이터를 찾는 알고리즘이다."],
        "keyword": "알고리즘",
        "desc": "이진 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다. 선형 검색은 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색을 말한다."
    },{
        "subject": "소프트웨어 개발",
        "question": "버블 정렬을 이용하여 다음 자료를 오름차순으로 정렬 할 경우 PASS 1의 결과는?",
        "question_desc": "9, 6, 7, 3, 5",
        "correct_answer": "6, 7, 3, 5, 9",
        "incorrect_answers": ["6, 9, 7, 3, 5","3, 9, 6, 7, 5","3, 6, 7, 9, 5"]
    },{
        "subject": "소프트웨어 개발",
        "question": "다음은 인스펙션(Inspection) 과정을 표현한 것이다. (가)~(마)에 들어갈 말을 보기에서 찾아 바르게 연결한 것은?",
        "question_img": "gisa2020_02_01",
        "correct_answer": "(나) - ㉠, (다) - ㉢",
        "incorrect_answers": ["(가) - ㉡, (나) - ㉢","(다) - ㉢, (라) - ㉤","(라) - ㉣, (마) - ㉢"],
        "desc": "가: 사전교육, 나: 준비, 다: 인스펜션 회의, 라: 수정, 마: 후속조치"
    },{
        "subject": "소프트웨어 개발",
        "question": "소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것은?",
        "correct_answer": "Refactoring",
        "incorrect_answers": ["Architecting","Specification","Renewal"],
        "desc": "Architecting: 설계, Specification: 명세서, Renewal: 유지보수"
    },{
        "subject": "소프트웨어 개발",
        "question": "단위 테스트(Unit Test)와 관련한 설명으로 틀린 것은?",
        "correct_answer": "필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.",
        "incorrect_answers": ["구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다","모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다"," 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다"],
        "desc": "스텁(Stub)은 통합 테스트이다.",
        "keyword": "통합 테스트"
    },{
        "subject": "소프트웨어 개발",
        "question": "IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명으로 틀린 것은?",
        "correct_answer": "Compile - 저급언어의 프로그램을 고급언어 프로그램으로 변환하는 기능",
        "incorrect_answers": ["Coding - 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성할 수 있는 환경을 제공","Debugging - 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능","Deployment - 소프트웨어를 최종 사용자에게 전달하기 위한 기능"],
        "desc": "컴파일은 소스코드(원시 프로그램)을 기계어 코드로 변환하는 기능이다."
    },{
        "subject": "소프트웨어 개발",
        "question": "아래 Tree 구조에 대하여 후위 순회(Postorder) 한 결과는?",
        "correct_answer": "d → b → g → h → e → f → c → a",
        "incorrect_answers": ["a → b → d → c → e → g → h → f","d → b → a → g → e → h → c → f","a → b → d → g → e → h → c → f"],
        "desc": "전위 운행 (PreOrder) → Root, Left, Right 순서<br>중위 운행(InOrder) → Left, Root, Right 순서<br>후위 운행(PostOrder) → Left, Right, Root 순서"
    },{
        "subject": "소프트웨어 개발",
        "question": " 인터페이스 구현 시 사용하는 기술로 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷은?",
        "correct_answer": "JSON",
        "incorrect_answers": ["HTML","AVPN","DOF"]
    },{
        "subject": "소프트웨어 개발",
        "question": "순서가 있는 리스트에서 데이터의 삽입(Push), 삭제(Pop)가 한 쪽 끝에서 일어나며 LIFO(Last-In-First-Out)의 특징을 가지는 자료구조는?",
        "correct_answer": "Stack",
        "incorrect_answers": ["Tree","Graph","Queue"],
        "desc": "Stack = LIFO, 한 쪽 끝에서 일어남<br>Queue = FIFO, 양방향에서 일어남<br>Tree &Graph는 비선형구조"
    },{
        "subject": "소프트웨어 개발",
        "question": "다음 중 단위 테스트 도구로 사용될 수 없는 것은?",
        "correct_answer": "IgpUnit",
        "incorrect_answers": ["CppUnit","JUnit","HttpUnit"],
        "keyword": "단위 테스트"
    },{
        "subject": "데이터베이스 구축",
        "question": "다음 조건을 모두 만족하는 정규형은?",
        "question_desc": "- 테이블 R에 속한 모든 도메인이 원자값만으로 구성되어 있다.<br>- 테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며, 키의 부분 집합이 결정자가 되는 부분 종속이 존재하지 않는다.<br>테이블 R에 존재하는 모든 함수적 종속에서 결정자가 후보키이다.",
        "correct_answer": "BCNF",
        "incorrect_answers": ["제1정규형","제2정규형","제3정규형"],
        "keyword": "정규형"
    },{
        "subject": "데이터베이스 구축",
        "question": "데이터베이스의 트랜잭션 성질들 중에서 다음 설명에 해당하는 것은?",
        "question_desc": "트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 원래 상태가 되도록 해야 한다.",
        "correct_answer": "Atomicity",
        "incorrect_answers": ["Consistency","Isolation","Durability"],
        "keyword": "트랜잭션",
        "desc" : "원자성(Atomicity) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 한다.<br>일관성(Consistency) : 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 한다.<br>고립성(Isolation) : 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않는다.<br>영속성(Durability) : 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억된다."
    },{
        "subject": "데이터베이스 구축",
        "question": "분산 데이터베이스 시스템과 관련한 설명으로 틀린 것은?",
        "correct_answer": "데이터베이스가 분산되어 있음을 사용자가 인식할 수 있도록 분산 투명성(Distribution Transparency)을 배제해야 한다.",
        "incorrect_answers": ["물리적으로 분산된 데이터베이스 시스템을 논리적으로 하나의 데이터베이스 시스템처럼 사용할 수 있도록 한 것이다.","물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 한다","분산 데이터베이스 시스템을 위한 통신 네트워크 구조가 데이터 통신에 영향을 주므로 효율적으로 설계해야 한다."],
        "keyword": "데이터베이스",
        "desc": "분산 데이터베이스의 목표에는 위치 투명성(Location Transparency), 중복(복제) 투명성(Replication Transparency), 병행 투명성(Concurrency Transparency), 장애 투명성(Fai ure Transparency) 등이 있다."
    },{
        "subject": "데이터베이스 구축",
        "question": "다음 테이블을 보고 강남지점의 판매량이 많은 제품부터 출력되도록 할 때 다음 중 가장 적절한 SQL 구문은? (단, 출력은 제품명과 판매량이 출력되도록 한다.)",
        "question_img": "gisa2020_02_03",
        "correct_answer": "SELECT 제품명, 판매량 FROM 푸드 WHERE 지점명 = '강남지점' ORDER BY 판매량 DESC;",
        "incorrect_answers": ["SELECT 제품명, 판매량 FROM 푸드 ORDER BY 판매량 ASC;","SELECT 제품명, 판매량 FROM 푸드 ORDER BY 판매량 DESC;","SELECT 제품명, 판매량 FROM 푸드 WHERE 지점명 = '강남지점' ORDER BY 판매량 ASC;"]
    },{
        "subject": "데이터베이스 구축",
        "question": "데이터베이스의 인덱스와 관련한 설명으로 틀린 것은?",
        "correct_answer": "인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다.",
        "incorrect_answers": ["문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조이다.","테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 된다.","대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다"],
        "desc": "CREATE(생성) DROP(삭제)"
    },{
        "subject": "데이터베이스 구축",
        "question": "물리적 데이터베이스 구조의 기본 데이터 단위인 저장 레코드의 양식을 설계할 때 고려 사항이 아닌 것은?",
        "correct_answer": "트랜잭션 모델링",
        "incorrect_answers": ["데이터 타입","데이터 값의 분포","접근 빈도"],
        "desc": "트랜잭션 모델링은 개념적 설계 단계에서 하는것이다."
    },{
        "subject": "데이터베이스 구축",
        "question": "SQL의 기능에 따른 분류 중에서 REVOKE문과 같이 데이터의 사용 권한을 관리하는데 사용하는 언어는?",
        "correct_answer": "DCL(Data Control Language)",
        "incorrect_answers": ["DDL(Data Definition Language)","DML(Data Manipulation Language)","DUL(Data User Language)"]
    },{
        "subject": "데이터베이스 구축",
        "question": "데이터 사전에 대한 설명으로 틀린 것은?",
        "correct_answer": "데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정 할 수 있다.",
        "incorrect_answers": ["시스템 카탈로그 또는 시스템 데이터베이스라고도 한다.","데이터베이스에 대한 데이터인 메타데이터(Metadata)를 저장하고 있다.","데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보는 데이터 디렉토리(Data Directory)라는 곳에서 관리한다."],
        "keyword": "데이터 사전",
        "desc": "데이터 사전(Data Dictionary)이란 시스템 자신이 필요로 하는 여러 가지 객체에 관한 정보를 포함하고 있는 시스템 데이터베이스이다. 시스템 카탈로그(System Catalog), 메타 데이터(Meta Data)라고도 한다."
    },{
        "subject": "데이터베이스 구축",
        "question": "데이터베이스에서 릴레이션에 대한 설명으로 틀린 것은?",
        "correct_answer": "하나의 릴레이션에서 튜플은 특정한 순서를 가진다.",
        "incorrect_answers": ["모든 튜플은 서로 다른 값을 가지고 있다","각 속성은 릴레이션 내에서 유일한 이름을 가진다","모든 속성 값은 원자 값(atomic value)을 가진다."],
        "keyword": "릴레이션"
    },{
        "subject": "데이터베이스 구축",
        "question": "데이터베이스에서의 뷰(View)에 대한 설명으로 틀린 것은?",
        "correct_answer": "뷰는 논리적으로 존재하는 기본 테이블과 다르게 물리적으로만 존재하며 카탈로그에 저장된다.",
        "incorrect_answers": ["뷰는 다른 뷰를 기반으로 새로운 뷰를 만들 수 있다.","뷰는 일종의 가상 테이블이며, update에는 제약이 따른다","뷰는 기본 테이블을 만드는 것처럼 create view를 사용하여 만들 수 있다."],
        "keyword": "뷰",
        "desc": "뷰는 논리적으로만 존재하며 카탈로그에 저장된다."
    },{
        "subject": "데이터베이스 구축",
        "question": "트랜잭션의 상태 중 트랜잭션의 마지막 연산이 실행된 직후의 상태로, 모든 연산의 처리는 끝났지만 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하지 않은 상태는?",
        "correct_answer": "Partially Committed",
        "incorrect_answers": ["Active","Committed","Aborted"],
        "keyword": "트랜잭션",
        "desc" : "트랜잭션의 상태는 활동(Active) - 실패(Failed) - 철회(Aborted) - 부분 완료(Partially Committed) - 완료(Committed)로 나눌 수 있다."
    },{
        "subject": "데이터베이스 구축",
        "question": "SQL의 명령을 사용 용도에 따라 DDL, DML, DCL로 구분 할 경우, 그 성격이 나머지 셋과 다른 것은?",
        "correct_answer": "GRANT",
        "incorrect_answers": ["SELECT","UPDATE","INSERT"],
        "keyword": "데이터베이스",
        "desc": "DDL: CREATE, ALTER, DROP<br> DML: SELECT, INSERT, UPDATE, DELETE<br>DCL: COMMIT, ROLLBACK, GRANT, REVOKE"
    },{
        "subject": "데이터베이스 구축",
        "question": "키의 종류 중 유일성과 최소성을 만족하는 속성 또는 속성들의 집합은?",
        "correct_answer": "Candidate key",
        "incorrect_answers": ["Atomic key","Super key","Test key"],
        "desc": "후보키(Candidate key)는 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합을 말한다.",
        "keyword": "키(key)"
    },{
        "subject": "데이터베이스 구축",
        "question": "데이터베이스에서 개념적 설계 단계에 대한 설명으로 틀린 것은?",
        "correct_answer": "트랜잭션 인터페이스를 설계 및 작성한다.",
        "incorrect_answers": ["산출물로 E-R Diagram을 만들 수 있다.","DBMS에 독립적인 개념 스키마를 설계한다","논리적 설계 단계의 앞 단계에서 수행된다."],
        "keyword": "데이터베이스 설계",
        "desc": "데이터베이스 설계는 요구 조건 분석 - 개념적 설계 - 논리적 설계 - 물리적 설계 - 구현으로 설계한다. <br>트랜잭션 인터페이스 설계는 논리적 설계에 해당한다."
    },{
        "subject": "데이터베이스 구축",
        "question": "테이블의 기본키(Primary Key)로 지정된 속성에 관한 설명으로 가장 거리가 먼 것은?",
        "correct_answer": "검색할 때 반드시 필요하다.",
        "incorrect_answers": ["NOT NULL로 널 값을 가지지 않는다.","릴레이션에서 튜플을 구별할 수 있다.","외래키로 참조될 수 있다."],
        "keyword": "키(key)",
        "desc": "기본키는 후보키 중에서 선정된 주키(MAIN KEY)로 중복된 값을 가질 수 없으며, 튜블을 식별하기 위해 반드시 필요한 키(Key)이다."
    },{
        "subject": "데이터베이스 구축",
        "question": "데이터 모델의 구성 요소 중 데이터 구조에 따라 개념 세계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?",
        "correct_answer": "Operation",
        "incorrect_answers": ["Relation","Data Structure","Constraint"],
        "keyword": "데이터 모델",
        "desc": "데이터 모델의 구성 요소에는 구조(Relation), 연산(Operation), 제약 조건(Constraint)이 있으며, 논리적 데이터 모델의 구성요소에는 개체, 속성, 관계가 있다."
    },{
        "subject": "데이터베이스 구축",
        "question": "다음 [조건]에 부합하는 SQL문을 작성하고자 할 때, [SQL문]의 빈칸에 들어갈 내용으로 옳은 것은? (단, '팀코드' 및 '이름'은 속성이며, '직원'은 테이블이다.)",
        "question_img": "gisa2020_02_04",
        "correct_answer": "SELECT 팀코드 FROM 직원 WHERE 이름 = '정도일'",
        "incorrect_answers": ["WHERE 이름 = '정도일'","SELECT 팀코드 FROM 이름 WHERE 직원 = '정도일'","WHERE 직원 = '정도일'"]
    },{
        "subject": "데이터베이스 구축",
        "question": "무결성 제약조건 중 개체 무결성 제약조건에 대한 설명으로 옳은 것은?",
        "correct_answer": "기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다",
        "incorrect_answers": ["릴레이션 내의 튜플들이 각 속성의 도메인에 정해진 값만을 가져야 한다.","자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 한다.","자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다."]
    },{
        "subject": "데이터베이스 구축",
        "question": "관계 데이터 모델에서 릴레이션(Relation)에 포함되어 있는 튜플(Tuple)의 수를 무엇이라고 하는가?",
        "correct_answer": "Cardinality",
        "incorrect_answers": ["Degree","Attribute","Cartesian product"]
    },{
        "subject": "데이터베이스 구축",
        "question": "사용자 'PARK'에게 테이블을 생성할 수 있는 권한을 부여하기 위한 SQL문의 구성으로 빈칸에 적합한 내용은?",
        "question_desc": "[SQL문]<br>GRANT (    ) PARK;",
        "correct_answer": "CREATE TABLE TO",
        "incorrect_answers": ["CREATE TO","CREATE FROM","CREATE TABLE FROM"]
    }
]